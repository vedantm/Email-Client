import sys, os
#from tkinter import *
#import tkinter.filedialog as tk_FileDialog
#from io import StringIO
from Tkinter import *
import tkFileDialog as tk_FileDialog
from StringIO import StringIO

rootWindowPosition = "+00+00"

fonttype = ("MS", "Sans", "Serif")
fontfamily    = ("Courier")

font1  = 10
font2     =  9  #a little smaller, because it it more legible at a smaller size
font3    = 12  # a little larger makes it easier to see

#STANDARD_SELECTION_EVENTS = ["Return", "Button-1"]
STANDARD_SELECTION_EVENTS = ["Return", "Button-1", "space"]

# Initialize some global variables that will be reset later
multipleselect = None
wtext = None
replytxtbutton = None
__choiceboxResults = None
__firstWidget = None
__enterboxText = None
__enterboxDefaultText=""
__multenterboxText = ""
choiceboxChoices = None
choiceboxWidget = None
entryWidget = None
boxRoot = None

def tabRight(event):
    boxRoot.event_generate("<Tab>")

def tabLeft(event):
    boxRoot.event_generate("<Shift-Tab>")

def bindArrows(widget):
    widget.bind("<Down>", tabRight)
    widget.bind("<Up>"  , tabLeft)

    widget.bind("<Right>",tabRight)
    widget.bind("<Left>" , tabLeft)

def ButtonEvent(event):
    """
    Handle an event that is generated by a person clicking a button.
    """
    global  boxRoot, wtext, replytxtbutton
    replytxtbutton = wtext[event.widget]
    boxRoot.quit() # quit the main loop

def buttonframebuttons(choices):
    """Put the buttons in the buttons frame
    """
    global wtext, __firstWidget, buttonsFrame

    __firstWidget = None
    wtext = {}

    i = 0

    for buttonText in choices:
        tempButton = Button(buttonsFrame, takefocus=1, text=buttonText)
        bindArrows(tempButton)
        tempButton.pack(expand=YES, side=LEFT, padx='1m', pady='1m', ipadx='2m', ipady='1m')

        # remember the text associated with this widget
        wtext[tempButton] = buttonText

        # remember the first widget, so we can put the focus there
        if i == 0:
            __firstWidget = tempButton
            i = 1

        # for the commandButton, bind activation events to the activation event handler
        commandButton  = tempButton
        handler = ButtonEvent
        for selectionEvent in STANDARD_SELECTION_EVENTS:
            commandButton.bind("<%s>" % selectionEvent, handler)


def newbuttonbox(msg="",title=" "
    ,choices=("1", "2")
    , image=None
    , root=None
    ):
    global boxRoot, replytxtbutton, wtext, buttonsFrame


    # Initialize replytxtbutton to the first choice.
    # This is what will be used if the window is closed by the close button.
    replytxtbutton = choices[0]

    if root:
        root.withdraw()
        boxRoot = Toplevel(master=root)
        boxRoot.withdraw()
    else:
        boxRoot = Tk()
        boxRoot.withdraw()

    #boxRoot.protocol('WM_DELETE_WINDOW', denyWindowManagerClose )
    boxRoot.title(title)
    boxRoot.iconname('Dialog')
    #boxRoot.geometry(rootWindowPosition)
    boxRoot.minsize(400, 100)

    # ------------- define the messageFrame ---------------------------------
    messageFrame = Frame(master=boxRoot)
    messageFrame.pack(side=TOP, fill=BOTH)

    # ------------- define the buttonsFrame ---------------------------------
    buttonsFrame = Frame(master=boxRoot)
    buttonsFrame.pack(side=TOP, fill=BOTH)

    # -------------------- place the widgets in the frames -----------------------
    messageWidget = Message(messageFrame, text=msg, width=400)
    messageWidget.configure(font=(fonttype,font1))
    messageWidget.pack(side=TOP, expand=YES, fill=X, padx='3m', pady='3m')

    buttonframebuttons(choices)

    # -------------- the action begins -----------
    # put the focus on the first button
    __firstWidget.focus_force()

    boxRoot.deiconify()
    boxRoot.mainloop()
    boxRoot.destroy()
    if root: root.deiconify()
    return replytxtbutton

def msgbox(msg="(message goes here)", title=" ", ok_button="OK",image=None,root=None):
    if type(ok_button) != type("OK"):
        raise AssertionError("The 'ok_button' argument to msgbox must be a string.")

    return newbuttonbox(msg=msg, title=title, choices=[ok_button], image=image,root=root)

def cancelpress(event):
    global __multenterboxText
    __multenterboxText = None
    boxRoot.quit()

def retreivetext(event):
    global __multenterboxText

    __multenterboxText = []
    for entryWidget in entryWidgets:
        __multenterboxText.append(entryWidget.get())
    boxRoot.quit()


#-----------------------------------------------------------------------
# fillentry
#-----------------------------------------------------------------------
def fillentry(msg="Fill in values for the fields."
    , title=" "
    , fields=()
    , values=()
    , mask = None
    ,defaultvalues=None
    ):
    global boxRoot, __multenterboxText, __multenterboxDefaultText, cancelButton, entryWidget, okButton

    choices = ["OK", "Cancel"]
    if len(fields) == 0: return None

    fields = list(fields[:])  # convert possible tuples to a list
    values = list(values[:])  # convert possible tuples to a list

    if   len(values) == len(fields): pass
    elif len(values) >  len(fields):
        fields = fields[0:len(values)]
    else:
        while len(values) < len(fields):
            values.append("")

    boxRoot = Tk()

    #boxRoot.protocol('WM_DELETE_WINDOW', denyWindowManagerClose )
    boxRoot.title(title)
    boxRoot.iconname('Dialog')
    #boxRoot.geometry(rootWindowPosition)
    boxRoot.bind("<Escape>", cancelpress)
    #boxRoot.attributes('-zoomed', '1')
    
    # -------------------- put subframes in the boxRoot --------------------
    messageFrame = Frame(master=boxRoot)
    messageFrame.pack(side=TOP, fill=BOTH)

    #-------------------- the msg widget ----------------------------
    messageWidget = Message(messageFrame, width="4.5i", text=msg)
    messageWidget.configure(font=(fonttype,font1))
    messageWidget.pack(side=RIGHT, expand=1, fill=BOTH, padx='3m', pady='3m')

    global entryWidgets
    entryWidgets = []

    lastWidgetIndex = len(fields) - 1

    for widgetIndex in range(len(fields)):
        argFieldName  = fields[widgetIndex]
        argFieldValue = values[widgetIndex]
        entryFrame = Frame(master=boxRoot)
        entryFrame.pack(side=TOP, fill=BOTH)

        # --------- entryWidget ----------------------------------------------
        labelWidget = Label(entryFrame, text=argFieldName)
        labelWidget.pack(side=LEFT)

        entryWidget = Entry(entryFrame, width=40,highlightthickness=2)
        if defaultvalues!=None:
			entryWidget.insert(0,defaultvalues[widgetIndex])
        entryWidgets.append(entryWidget)
        entryWidget.configure(font=(fonttype,font3))
        entryWidget.pack(side=RIGHT, padx="3m")

        bindArrows(entryWidget)

        entryWidget.bind("<Return>", retreivetext)
        entryWidget.bind("<Escape>", cancelpress)

        # for the last entryWidget, if this is a passwordbox,
        # show the contents as just asterisks
        if widgetIndex == lastWidgetIndex:
            if mask:
                entryWidgets[widgetIndex].configure(show=mask)

        # put text into the entryWidget
        entryWidgets[widgetIndex].insert(0,argFieldValue)
        widgetIndex += 1

    # ------------------ ok button -------------------------------
    buttonsFrame = Frame(master=boxRoot)
    buttonsFrame.pack(side=BOTTOM, fill=BOTH)

    okButton = Button(buttonsFrame, takefocus=1, text="OK")
    bindArrows(okButton)
    okButton.pack(expand=1, side=LEFT, padx='3m', pady='3m', ipadx='2m', ipady='1m')

    # for the commandButton, bind activation events to the activation event handler
    commandButton  = okButton
    handler = retreivetext
    for selectionEvent in STANDARD_SELECTION_EVENTS:
        commandButton.bind("<%s>" % selectionEvent, handler)


    # ------------------ cancel button -------------------------------
    cancelButton = Button(buttonsFrame, takefocus=1, text="Cancel")
    bindArrows(cancelButton)
    cancelButton.pack(expand=1, side=RIGHT, padx='3m', pady='3m', ipadx='2m', ipady='1m')

    # for the commandButton, bind activation events to the activation event handler
    commandButton  = cancelButton
    handler = cancelpress
    for selectionEvent in STANDARD_SELECTION_EVENTS:
        commandButton.bind("<%s>" % selectionEvent, handler)


    # ------------------- time for action! -----------------
    entryWidgets[0].focus_force()    # put the focus on the entryWidget
    boxRoot.mainloop()  # run it!

    # -------- after the run has completed ----------------------------------
    boxRoot.destroy()  # button_click didn't destroy boxRoot, so we do it now
    return __multenterboxText


#-----------------------------------------------------------------------
# passwordbox
#-----------------------------------------------------------------------
def passwordbox(msg="Fill in values for the fields."
    , title=" "
    , fields=tuple()
    ,values=tuple()
    ,defaultvalues=[]
    ):
    return fillentry(msg,title,fields,values,'*',defaultvalues)

def buttonbox(msg="",title=" "
    ,choices=( "Inbox","Forward","Reply", "Delete","Compose","Display Mail")
    ,mails=[]
    ,image=None
    , root=None
    ):
    global boxRoot, replytxtbutton, wtext, buttonsFrame


     #Initialize replytxtbutton to the first choice.
     #This is what will be used if the window is closed by the close button.
    replytxtbutton = choices[0]

    if root:
        root.withdraw()
        boxRoot = Toplevel(master=root)
        boxRoot.withdraw()
    else:
        boxRoot = Tk()
        boxRoot.withdraw()
	

    boxRoot.title(title)
    rootWindowPosition = "+0+0"
    boxRoot.expand=NO
    boxRoot.iconname('Dialog')
    boxRoot.attributes('-zoomed', '1')

    messageFrame = Frame(master=boxRoot)
    messageFrame.pack(side=TOP, fill=BOTH)

    buttonsFrame = Frame(master=boxRoot)
    buttonsFrame.pack(side=TOP, fill=BOTH)

    messageWidget = Message(messageFrame, text=msg, width=800)
    messageWidget.configure(font=(fonttype,font1))
    messageWidget.pack(side=TOP, expand=YES, fill=X, padx='4m', pady='7m')

    buttonframebuttons(choices)
    radioFrame = Frame(master=boxRoot)
    radioFrame.pack()
    
    v=IntVar()
    v.set(0)
    val=0
    for a in mails:
		Radiobutton(master=boxRoot, text=a, variable=v, value=val).pack(anchor=W,pady="1m")
		val=val+1
	
		

     #-------------- the action begins -----------
     #put the focus on the first button
    __firstWidget.focus_force()

	

    boxRoot.deiconify()
    boxRoot.mainloop()
    boxRoot.destroy()
    if root: root.deiconify()
    toReturn = [replytxtbutton,v.get()]
    #print "VVVVVVVVVVVVVVVVVVVVV: ",v.get()
    #return replytxtbutton
    return toReturn

def getfile(msg
    , title
    ):
    if msg and title: return "%s - %s" % (title,msg)
    if msg and not title: return str(msg)
    if title and not msg: return str(title)
    return None # no message and no title


class FileTypeObject:
    def __init__(self,filemask):
        if len(filemask) == 0:
            raise AssertionError('Filetype argument is empty.')

        self.masks = []

        if type(filemask) == type("abc"):  # a string
            self.initializeFromString(filemask)

        elif type(filemask) == type([]): # a list
            if len(filemask) < 2:
                raise AssertionError('Invalid filemask.\n'
                +'List contains less than 2 members: "%s"' % filemask)
            else:
                self.name  = filemask[-1]
                self.masks = list(filemask[:-1] )
        else:
            raise AssertionError('Invalid filemask: "%s"' % filemask)

    def __eq__(self,other):
        if self.name == other.name: return True
        return False

    def add(self,other):
        for mask in other.masks:
            if mask in self.masks: pass
            else: self.masks.append(mask)

    def toTuple(self):
        return (self.name,tuple(self.masks))

    def isAll(self):
        if self.name == "All files": return True
        return False

    def initializeFromString(self, filemask):
        # remove everything except the extension from the filemask
        self.ext = os.path.splitext(filemask)[1]
        if self.ext == "" : self.ext = ".*"
        if self.ext == ".": self.ext = ".*"
        self.name = self.getName()
        self.masks = ["*" + self.ext]

    def getName(self):
        e = self.ext
        if e == ".*"  : return "All files"
        if e == ".txt": return "Text files"
        if e == ".py" : return "Python files"
        if e == ".pyc" : return "Python files"
        if e == ".xls": return "Excel files"
        if e.startswith("."):
            return e[1:].upper() + " files"
        return e.upper() + " files"


def fileboxSetup(default,filetypes):
    if not default: default = os.path.join(".","*")
    initialdir, initialfile = os.path.split(default)
    if not initialdir : initialdir  = "."
    if not initialfile: initialfile = "*"
    initialbase, initialext = os.path.splitext(initialfile)
    initialFileTypeObject = FileTypeObject(initialfile)

    allFileTypeObject = FileTypeObject("*")
    ALL_filetypes_was_specified = False

    if not filetypes: filetypes= []
    filetypeObjects = []

    for filemask in filetypes:
        fto = FileTypeObject(filemask)

        if fto.isAll():
            ALL_filetypes_was_specified = True # remember this

        if fto == initialFileTypeObject:
            initialFileTypeObject.add(fto) # add fto to initialFileTypeObject
        else:
            filetypeObjects.append(fto)

    if ALL_filetypes_was_specified:
        pass
    elif allFileTypeObject == initialFileTypeObject:
        pass
    else:
        filetypeObjects.insert(0,allFileTypeObject)
    if len(filetypeObjects) == 0:
        filetypeObjects.append(initialFileTypeObject)

    if initialFileTypeObject in (filetypeObjects[0], filetypeObjects[-1]):
        pass
    else:
        if runningPython26:
            filetypeObjects.append(initialFileTypeObject)
        else:
            filetypeObjects.insert(0,initialFileTypeObject)

    filetypes = [fto.toTuple() for fto in filetypeObjects]

    return initialbase, initialfile, initialdir, filetypes


def myfileopenbox(msg=None
    , title=None
    , default="*"
    , filetypes=None
    ):

    localRoot = Tk()
    localRoot.withdraw()

    initialbase, initialfile, initialdir, filetypes = fileboxSetup(default,filetypes)

    if (initialfile.find("*") < 0) and (initialfile.find("?") < 0):
        initialfile = None
    elif initialbase == "*":
        initialfile = None

    f = tk_FileDialog.askopenfilename(parent=localRoot
        , title=getfile(msg,title)
        , initialdir=initialdir
        , initialfile=initialfile
        , filetypes=filetypes
        )

    localRoot.destroy()

    if not f: return ""
    #print "f:" , f
    #return f
    return os.path.normpath(f)
    
def retreivetextCompose(event):
    global __multenterboxText

    __multenterboxText = []
    for entryWidget in range(len(entryWidgets)-1):
        __multenterboxText.append(entryWidgets[entryWidget].get())
        
    __multenterboxText.append(entryWidgets[entryWidget+1].get('1.0',END))
        
    boxRoot.quit()

    
#-----------------------------------------------------------------------
# fillentrycompose
#-----------------------------------------------------------------------
def fillentrycompose(msg="Fill in values for the fields."
    , title=" "
    , fields=()
    , values=()
    , forwardto=""
    , subject=""
    , body=""
    , mask = None
    ):
    global boxRoot, __multenterboxText, __multenterboxDefaultText, cancelButton, entryWidget, okButton

    choices = ["Send", "Cancel"]
    if len(fields) == 0: return None

    fields = list(fields[:])  # convert possible tuples to a list
    values = list(values[:])  # convert possible tuples to a list

    if   len(values) == len(fields): pass
    elif len(values) >  len(fields):
        fields = fields[0:len(values)]
    else:
        while len(values) < len(fields):
            values.append("")

    boxRoot = Tk()
	
    screen_width  = boxRoot.winfo_screenwidth()
    screen_height = boxRoot.winfo_screenheight()
    root_width    = int((screen_width*0.8 ))
    root_height   = int((screen_height*0.8))
    root_xpos     = int((0))
    root_ypos     = int((0))

    boxRoot.title(title)
    rootWindowPosition = "+0+0"
    boxRoot.expand=NO
    boxRoot.geometry("%dx%d+0+0" % (root_width, root_height))
    boxRoot.title(title)
    boxRoot.iconname('Dialog')
    boxRoot.geometry(rootWindowPosition)
    boxRoot.attributes('-zoomed', '1')
    boxRoot.bind("<Escape>", cancelpress)

    messageFrame = Frame(master=boxRoot)
    messageFrame.pack(side=TOP, fill=BOTH)

    messageWidget = Message(messageFrame, width="4.5i", text=msg)
    messageWidget.configure(font=(fonttype,font1))
    messageWidget.pack(side=RIGHT, expand=1, fill=BOTH, padx='3m', pady='3m')

    global entryWidgets
    entryWidgets = []

    lastWidgetIndex = len(fields) - 1
    for widgetIndex in range(len(fields)):		
		argFieldName  = fields[widgetIndex]
		argFieldValue = values[widgetIndex]
		entryFrame = Frame(master=boxRoot)
		entryFrame.pack(side=TOP, fill=BOTH)

		labelWidget = Label(entryFrame, text=argFieldName)
		labelWidget.pack(side=LEFT)
		if(widgetIndex < len(fields)-1):
			entryWidget = Entry(entryFrame, width=105,highlightthickness=2)
			entryWidgets.append(entryWidget)
			entryWidget.configure(font=(fonttype,font3))
			entryWidget.pack(side=RIGHT, padx="3m")
			if(widgetIndex==0):
				entryWidget.insert(0,forwardto)
			if(widgetIndex==3):
				entryWidget.insert(0,subject)		
			if(widgetIndex==4):
				entryWidget.insert(0,(myfileopenbox(title="Attach a File")))
			entryWidget.bind("<Return>", retreivetext)
			entryWidget.bind("<Escape>", cancelpress)
			bindArrows(entryWidget)
			entryWidgets[widgetIndex].insert(0,argFieldValue)
		else:
			textWidget = Text(entryFrame,width=150,height=30)
			entryWidgets.append(textWidget)
			textWidget.pack(side=RIGHT, padx="3m")
			textWidget.insert(END,body)
			#textWidget.bind("<Return>", retreivetextCompose)
			#textWidget.bind("<Escape>", cancelpress)
			bindArrows(textWidget)
		
		widgetIndex += 1

		
    # ------------------ ok button -------------------------------
    buttonsFrame = Frame(master=boxRoot)
    buttonsFrame.pack(side=BOTTOM, fill=BOTH)

    okButton = Button(buttonsFrame, takefocus=1, text="Send")
    bindArrows(okButton)
    okButton.pack(expand=1, side=LEFT, padx='3m', pady='3m', ipadx='2m', ipady='1m')

    # for the commandButton, bind activation events to the activation event handler
    commandButton  = okButton
    handler = retreivetextCompose
    for selectionEvent in STANDARD_SELECTION_EVENTS:
        commandButton.bind("<%s>" % selectionEvent, handler)


    # ------------------ cancel button -------------------------------
    cancelButton = Button(buttonsFrame, takefocus=1, text="Cancel")
    bindArrows(cancelButton)
    cancelButton.pack(expand=1, side=RIGHT, padx='3m', pady='3m', ipadx='2m', ipady='1m')

    # for the commandButton, bind activation events to the activation event handler
    commandButton  = cancelButton
    handler = cancelpress
    for selectionEvent in STANDARD_SELECTION_EVENTS:
        commandButton.bind("<%s>" % selectionEvent, handler)


    entryWidgets[0].focus_force()    # put the focus on the entryWidget
    boxRoot.mainloop()  # run it!

    boxRoot.destroy()  # button_click didn't destroy boxRoot, so we do it now
    
    #toReturn = __multenterboxText.append()	
    return __multenterboxText
    

def mycomposebox(msg="Fill in values for the fields."
    , title=" "
    , fields=()
    , forwardto=""
    , subject=""
    , body=""
    , values=()
    ):
    return fillentrycompose(msg,title,fields,values,forwardto,subject,body,None)

def OKpress(event):
    global boxRoot
    boxRoot.quit()


def textbox(msg=""
    , title=" "
    , text=""
    , codebox=0
    ):

	if msg == None: msg = ""
	if title == None: title = ""

	global boxRoot, replytxtbutton, wtext, buttonsFrame
	global rootWindowPosition
	choices = ["OK"]
	replytxtbutton = choices[0]


	boxRoot = Tk()

	screen_width  = boxRoot.winfo_screenwidth()
	screen_height = boxRoot.winfo_screenheight()
	root_width = int((screen_width * 0.8))
	root_height = int((screen_height * 0.5))
	root_xpos = int((screen_width * 0.1))
	root_ypos = int((screen_height * 0.05))

	boxRoot.title(title)
	boxRoot.iconname('Dialog')
	rootWindowPosition = "+0+0"
	boxRoot.geometry(rootWindowPosition)
	boxRoot.expand=NO
	boxRoot.attributes('-zoomed', '1')

	mainframe = Frame(master=boxRoot)
	mainframe.pack(side=TOP, fill=BOTH, expand=YES)

	# ----  put frames in the window -----------------------------------
	# we pack the textboxFrame first, so it will expand first
	textboxFrame = Frame(mainframe, borderwidth=3)
	textboxFrame.pack(side=BOTTOM , fill=BOTH, expand=YES)

	message_and_buttonsFrame = Frame(mainframe)
	message_and_buttonsFrame.pack(side=TOP, fill=X, expand=NO)

	messageFrame = Frame(message_and_buttonsFrame)
	messageFrame.pack(side=LEFT, fill=X, expand=YES)

	buttonsFrame = Frame(message_and_buttonsFrame)
	buttonsFrame.pack(side=RIGHT, expand=NO)

	# -------------------- put widgets in the frames --------------------

	# put a textArea in the top frame
	character_width = int((root_width * 0.6) / font2)
	textArea = Text(
		textboxFrame
		, height=25
		, width=character_width
		, padx="2m"
		, pady="1m"
		)
	textArea.configure(wrap=WORD)
	textArea.configure(font=(fonttype,font1))


	# some simple keybindings for scrolling
	mainframe.bind("<Next>" , textArea.yview_scroll( 1,PAGES))
	mainframe.bind("<Prior>", textArea.yview_scroll(-1,PAGES))

	mainframe.bind("<Right>", textArea.xview_scroll( 1,PAGES))
	mainframe.bind("<Left>" , textArea.xview_scroll(-1,PAGES))

	mainframe.bind("<Down>", textArea.yview_scroll( 1,UNITS))
	mainframe.bind("<Up>"  , textArea.yview_scroll(-1,UNITS))


	# add a vertical scrollbar to the frame
	rightScrollbar = Scrollbar(textboxFrame, orient=VERTICAL, command=textArea.yview)
	textArea.configure(yscrollcommand = rightScrollbar.set)

	# add a horizontal scrollbar to the frame
	bottomScrollbar = Scrollbar(textboxFrame, orient=HORIZONTAL, command=textArea.xview)
	textArea.configure(xscrollcommand = bottomScrollbar.set)

	if codebox:
		bottomScrollbar.pack(side=BOTTOM, fill=X)
	rightScrollbar.pack(side=RIGHT, fill=Y)

	textArea.pack(side=LEFT, fill=BOTH, expand=YES)


	# ---------- put a msg widget in the msg frame-------------------
	messageWidget = Message(messageFrame, anchor=NW, text=msg, width=int(root_width * 0.9))
	messageWidget.configure(font=(fonttype,font1))
	messageWidget.pack(side=LEFT, expand=YES, fill=BOTH, padx='1m', pady='1m')

	# put the buttons in the buttonsFrame
	okButton = Button(buttonsFrame, takefocus=YES, text="OK", height=1, width=6)
	okButton.pack(expand=NO, side=TOP,  padx='2m', pady='1m', ipady="1m", ipadx="2m")

	# for the commandButton, bind activation events to the activation event handler
	commandButton  = okButton
	handler = OKpress
	for selectionEvent in ["Return","Button-1","Escape"]:
		commandButton.bind("<%s>" % selectionEvent, handler)


	try:
		# load the text into the textArea
		if type(text) == type("abc"): pass
		else:
			try:
				text = "".join(text)  # convert a list or a tuple to a string
			except:
				msgbox("Exception when trying to convert "+ str(type(text)) + " to text in textArea")
				sys.exit(16)
		textArea.insert(END,text, "normal")

	except:
		msgbox("Exception when trying to load the textArea.")
		sys.exit(16)

	try:
		okButton.focus_force()
	except:
		msgbox("Exception when trying to put focus on okButton.")
		sys.exit(16)

	boxRoot.mainloop()

	# this line MUST go before the line that destroys boxRoot
	areaText = textArea.get(0.0,END)
	boxRoot.destroy()
	return areaText # return replytxtbutton

